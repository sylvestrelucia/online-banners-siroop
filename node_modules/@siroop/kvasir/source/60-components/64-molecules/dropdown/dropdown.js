import keycodes from 'keycodes';

export const SELECTORS = {
	select: '.js-m-dropdown__select',
	faux: '.js-m-dropdown__faux',
	toggle: '.js-m-dropdown__toggle',
	option: '.js-m-dropdown__option',
	text: '.js-m-dropdown__text',
};

export const CLASSES = {
	opened: 'is-opened',
	selected: 'is-selected',
	hasValue: 'has-value',
	visible: 'js-visible',
	hidden: 'js-hidden',
};

class Dropdown {
	constructor($el) {
		this.$el = $el;
		this.$select = $el.find(SELECTORS.select);
		this.$selectOptions = this.$select.find('option');
		this.$faux = $el.find(SELECTORS.faux);
		this.$toggle = $el.find(SELECTORS.toggle);
		this.$text = $el.find(SELECTORS.text);
		this.$options = $el.find(SELECTORS.option);
		this.optionNumber = this.$options.length;
		this.keydownEventListener = this.keyboardNavigationHandler.bind(this);

		$('html').on('click', this.generalClickHandler.bind(this));

		this.registerEventListeners();
		this.replaceDropdown();
	}

	// if js is enabled, hide the select and use the faux dropdown
	replaceDropdown() {
		this.$select.addClass(CLASSES.hidden);
		this.$faux.addClass(CLASSES.visible);
	}

	generalClickHandler(event) {
		if (!$.contains(this.$el.get(0), event.target)) {
			this.close(false);
		}
	}

	registerEventListeners() {
		this.$toggle.on('click', this.toggle.bind(this));
		this.$toggle.on('click', this.startListeningForKeyboardNavigation.bind(this));
		this.$options.on('click', ev => this.selectOption($(ev.currentTarget)));
	}

	startListeningForKeyboardNavigation(event) {
		event.preventDefault();

		this.$el.on('keydown', this.keydownEventListener);
		const $selectedOption = this.$options.filter(`.${CLASSES.selected}`);
		if ($selectedOption.length > 0) {
			this.focusedOption = $selectedOption.parent().index();
		} else {
			this.focusedOption = -1;
		}
	}

	keyboardNavigationHandler(event) {
		const keycode = event.which;
		const keyname = keycodes(keycode);

		switch (keyname) {
		case 'down':
			this.focusNextOption();
			event.preventDefault();
			break;
		case 'up':
			this.focusPreviousOption();
			event.preventDefault();
			break;
		default:
		}
	}

	focusOptionAtIndex(index) {
		if (index > -1) {
			const $option = $(this.$options.get(index));
			$option.focus();
		} else {
			this.$toggle.focus();
		}
		this.focusedOption = index;
	}

	focusNextOption() {
		const nextOptionIndex = Math.min(this.focusedOption + 1, this.optionNumber - 1);
		this.focusOptionAtIndex(nextOptionIndex);
	}

	focusPreviousOption() {
		const nextOptionIndex = Math.max(this.focusedOption - 1, -1);
		this.focusOptionAtIndex(nextOptionIndex);
	}

	stopListeningForKeyboardNavigation() {
		this.$el.off('keydown', this.keydownEventListener);
	}

	toggle() {
		this.$faux.toggleClass(CLASSES.opened);
	}

	close(alsoFocus = true) {
		this.$faux.removeClass(CLASSES.opened);
		if (alsoFocus) {
			this.$toggle.focus();
		}
		this.stopListeningForKeyboardNavigation();
	}

	selectOption($option) {
		const selectedHtml = $option.html();
		const index = $option.parent().index();
		const $selectedOption = $(this.$selectOptions.get(index));

		this.$options.removeClass(CLASSES.selected);
		this.$toggle.addClass(CLASSES.hasValue);
		this.$text.html(selectedHtml);
		this.$selectOptions.attr('selected', false);

		$option.addClass(CLASSES.selected);
		$selectedOption.attr('selected', true);
		this.close();
	}
}

export default Dropdown;
