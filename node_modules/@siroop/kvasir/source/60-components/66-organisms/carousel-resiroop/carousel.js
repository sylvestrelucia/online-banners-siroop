import Siema from 'siema';

const CLASSES = {
	arrows: 'arrows',
	pagination: 'pagination',
	thumbnailCarousel: 'thumbnails',
	items: 'items',
	item: 'item',
	prev: 'prev',
	next: 'next',
	active: 'active',
};

const SELECTOR = {
	thumbnailCarouselItems: '.thumbnails .items',
	pagination: '.pagination',
	image: 'img',
};

const prevArrowIcon = `
	<svg fill="none" stroke="currentColor" stroke-width="5%" viewBox="0 0 1024 1024" width="100%" height="100%">
		<polyline points="699.7,886.5 324.7,511.5 700.7,136.5"></polyline>
	</svg>
`;

const nextArrowIcon = `
	<svg fill="none" stroke="currentColor" stroke-width="5%" viewBox="0 0 1024 1024" width="100%" height="100%">
		<polyline points="325.2,137 700.2,512 324.2,887"></polyline>
	</svg>
`;

const loadingSrc = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';

class ResiroopCarousel extends Siema {
	constructor(options) {
		super(options);

		this.window = window;

		this.labels = {
			prev: this.config.labels ? this.config.labels.prev : this.selector.getAttribute('data-label-prev'),
			next: this.config.labels ? this.config.labels.next : this.selector.getAttribute('data-label-next'),
		};

		if (this.config.thumbnails) {
			this.optionsThumbnails = Object.assign(
				this.config.thumbnails,
				{
					class: CLASSES.thumbnailCarousel,
					selector: SELECTOR.thumbnailCarouselItems,
					labels: this.labels,
				},
			);

			if (this.window.matchMedia('(min-width: 768px)').matches) {
				this.addThumbnails();
				this.thumbnailCarouselInstance = new ResiroopCarousel(this.optionsThumbnails);
			}

			window.addEventListener('resize', this.debounce(() => {
				if (this.thumbnailCarouselInstance && this.thumbnailCarousel) {
					this.thumbnailCarouselInstance.init();
				} else {
					this.addThumbnails();
					this.thumbnailCarouselInstance = new ResiroopCarousel(this.optionsThumbnails);
				}
			}, 100));
		}

		if (this.config.arrows) {
			this.addArrows();
		}

		if (this.config.pagination) {
			this.addPagination();
		}

		this.onInit(this.currentSlide);

		this.selector.addEventListener('touchstart', () => this.onUpdate(this.currentSlide));
		this.selector.addEventListener('touchend', () => this.onUpdate(this.currentSlide));
		this.selector.addEventListener('touchmove', () => this.onUpdate(this.currentSlide));
		this.selector.addEventListener('click', () => this.onUpdate(this.currentSlide));
	}

	onReplaceDataAttr(currentSlide) {
		for (let i = 0; i < this.config.perPage; i += 1) {
			const currentImage = this.innerElements[currentSlide + i].querySelector(SELECTOR.image);

			if ((currentImage.getAttribute('src') === '' || currentImage.getAttribute('src') === loadingSrc) && currentImage.hasAttribute('data-carousel-src')) {
				const dataSrcValue = currentImage.getAttribute('data-carousel-src');
				currentImage.setAttribute('src', dataSrcValue);
				currentImage.onload = () => {
					currentImage.removeAttribute('data-carousel-src');
				};

				if (currentImage.hasAttribute('data-carousel-srcset')) {
					const dataSrcSetValue = currentImage.getAttribute('data-carousel-srcset');
					currentImage.setAttribute('srcset', dataSrcSetValue);
				}
			}
		}
	}

	debounce(fn, wait) {
		let timeout;
		return (...args) => {
			clearTimeout(timeout);
			timeout = setTimeout(() => fn.apply(this, args), (wait || 1));
		};
	}

	onInit(currentSlide) {
		this.innerElements.map(obj => obj.setAttribute('style', 'display: block;'));
		this.onUpdate(currentSlide);
	}

	onUpdate(currentSlide) {
		if (currentSlide < 0) {
			this.updateCarousel(this.innerElements.length - 1);
		} else if (currentSlide === this.innerElements.length) {
			this.updateCarousel(0);
		} else {
			this.updateCarousel(currentSlide);
		}
	}

	updateCarousel(currentSlide) {
		if (this.config.lazyload) {
			this.onReplaceDataAttr(currentSlide);
		}

		if (this.config.thumbnails && this.thumbnailCarouselInstance) {
			const thumbnailCarousel = this.thumbnailCarouselInstance;
			const lastItem = thumbnailCarousel.innerElements.length - thumbnailCarousel.config.perPage;
			thumbnailCarousel.goTo(currentSlide > lastItem ? lastItem : currentSlide);
			for (let i = 0; i < thumbnailCarousel.innerElements.length; i += 1) {
				thumbnailCarousel.innerElements[i].classList.remove(CLASSES.active);
			}
			thumbnailCarousel.innerElements[currentSlide].classList.add(CLASSES.active);

			if (thumbnailCarousel.config.arrows) {
				thumbnailCarousel.updateArrows(currentSlide);
			}
		}

		if (this.config.pagination) {
			const pagination = this.selector.parentNode.querySelector(SELECTOR.pagination);
			for (let i = 0; i < pagination.childNodes.length; i += 1) {
				pagination.childNodes[i].classList.remove(CLASSES.active);
			}
			pagination.children[currentSlide].classList.add(CLASSES.active);
		}

		if (this.config.arrows) {
			this.updateArrows(currentSlide);
		}
	}

	updateArrows(currentSlide) {
		const itemsCount = this.innerElements.length - this.config.perPage;
		this.nextArrow.style.display = 'block';
		this.prevArrow.style.display = 'block';

		if (this.innerElements.length <= this.config.perPage && this.config.loop) {
			this.prevArrow.style.display = 'none';
			this.nextArrow.style.display = 'none';
		}

		if (!this.config.loop) {
			if (currentSlide < 1 || this.innerElements.length <= this.config.perPage) {
				this.prevArrow.style.display = 'none';
			}

			if (currentSlide >= itemsCount || this.innerElements.length <= this.config.perPage) {
				this.nextArrow.style.display = 'none';
			}
		}
	}

	addArrows() {
		this.arrows = document.createElement('div');
		this.arrows.setAttribute('class', CLASSES.arrows);
		this.prevArrow = document.createElement('button');
		this.prevArrow.setAttribute('class', CLASSES.prev);

		if (!this.labels.prev || !this.labels.next) {
			throw new Error('No data-label-prev or data-label-next attribute on carousel tag found ðŸ˜­');
		}

		this.prevArrow.setAttribute('aria-label', this.labels.prev);
		this.nextArrow = document.createElement('button');
		this.nextArrow.setAttribute('class', CLASSES.next);
		this.nextArrow.setAttribute('aria-label', this.labels.next);
		this.prevArrow.innerHTML = prevArrowIcon;
		this.nextArrow.innerHTML = nextArrowIcon;
		this.arrows.appendChild(this.prevArrow);
		this.arrows.appendChild(this.nextArrow);
		this.prevArrow.addEventListener('click', () => this.prev(1, this.onUpdate(this.currentSlide - 1)));
		this.nextArrow.addEventListener('click', () => this.next(1, this.onUpdate(this.currentSlide + 1)));
		this.selector.parentNode.insertBefore(this.arrows, this.selector.nextSibling);
	}

	addPagination() {
		this.pagination = document.createElement('div');
		this.pagination.setAttribute('class', CLASSES.pagination);
		for (let i = 0; i < this.innerElements.length; i += 1) {
			const btn = document.createElement('button');
			btn.textContent = i;
			btn.addEventListener('click', () => this.goTo(i, this.onUpdate(i)));
			this.pagination.appendChild(btn);
		}
		this.selector.parentNode.insertBefore(this.pagination, this.selector.nextSibling);
	}

	addThumbnails() {
		this.thumbnailCarousel = document.createElement('div');
		this.thumbnailCarousel.setAttribute('class', CLASSES.thumbnailCarousel);
		const thumbnailCarouselItems = document.createElement('div');
		thumbnailCarouselItems.setAttribute('class', CLASSES.items);
		for (let i = 0; i < this.innerElements.length; i += 1) {
			const button = document.createElement('button');
			button.setAttribute('class', CLASSES.item);
			button.addEventListener('click', () => this.goTo(i, this.onUpdate(i)));
			const img = document.createElement('img');

			if (!this.innerElements[i].querySelector('img').getAttribute('data-thumbnail')) {
				throw new Error('No data-thumbnail attribute on image tag found ðŸ˜­');
			}

			img.src = this.innerElements[i].querySelector('img').getAttribute('data-thumbnail');
			button.appendChild(img);
			thumbnailCarouselItems.appendChild(button);
		}
		this.thumbnailCarousel.insertBefore(thumbnailCarouselItems, this.thumbnailCarousel.nextSibling);
		this.selector.parentNode.parentNode.insertBefore(
			this.thumbnailCarousel,
			this.selector.parentNode.nextSibling,
		);
	}
}

export default ResiroopCarousel;
